{"version":3,"sources":["..\\react-todomvc.fsx"],"names":[],"mappings":"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","file":"react-todomvc.js","sourcesContent":["(**\r\n - title: React TodoMVC with Fable\r\n - tagline: Unveil the power of React and functional programming!\r\n - app-style: width:800px; margin:20px auto 50px auto;\r\n - intro: This is a port of [React TodoMVC](http://todomvc.com/examples/react/) to show how easy\r\n   is to take advantage of the full power of [React](https://facebook.github.io/react/) in Fable apps.\r\n   You can also compare the [F# source code](https://github.com/fable-compiler/Fable/blob/master/samples/browser/react-todomvc/react-todomvc.fsx)\r\n   with the [original JS implementation](https://github.com/tastejs/todomvc/tree/gh-pages/examples/react)\r\n   to see the advantages of Fable programming. There's also a port of the [React tutorial](https://github.com/fable-compiler/Fable/tree/master/samples/browser/react-tutorial),\r\n   including an express server and hot reloading. And remember [Fable is also compatible with React Native](http://www.navision-blog.de/blog/2016/08/06/fable-react-native/) for mobile development!\r\n*)\r\n\r\n(**\r\n## JavaScript bindings and helpers\r\n\r\nFable includes [React bindings and helpers](https://www.npmjs.com/package/fable-import-react)\r\nto make interaction with the tool more idiomatic in F#. We will also load a couple more of\r\nJS libraries: [classnames](https://github.com/JedWatson/classnames) and\r\n[director](https://github.com/flatiron/director).\r\n*)\r\n\r\n#r \"../../node_modules/fable-core/Fable.Core.dll\"\r\n#r \"../../node_modules/fable-react/Fable.React.dll\"\r\n\r\nopen System\r\nopen Fable.Core\r\nopen Fable.Core.JsInterop\r\nopen Fable.Import\r\n\r\n// JS utility for conditionally joining classNames together\r\nlet classNames: obj->string = importDefault \"./lib/classnames.js\"\r\n\r\n// Director is a router. Routing is the process of determining\r\n// what code to run when a URL is requested.\r\nlet Router: obj->obj = importDefault \"./lib/director.js\"\r\n\r\n(**\r\n## Utility module\r\n\r\nThis module is the equivalent of [utils.js](https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/utils.js)\r\nin the original implementation. Note we only need a couple of functions to load\r\nand save data from the browser local storage as things like Guid generation\r\n(`System.Guid.NewGuid()`) or record immutable updates are built-in in F#/Fable.\r\n\r\n> Because our `Todo` type is really simple (see below), `JSON.parse` will meet our needs.\r\nFor more complicated structures see [JSON serialization with Fable](https://fable-compiler.github.io/docs/interacting.html#JSON-serialization).\r\n*)\r\n\r\nmodule Util =\r\n    let load<'T> key =\r\n        Browser.localStorage.getItem(key) |> unbox\r\n        |> Option.map (JS.JSON.parse >> unbox<'T>)\r\n\r\n    let save key (data: 'T) =\r\n        Browser.localStorage.setItem(key, JS.JSON.stringify data)\r\n\r\n(**\r\n## Model definiton\r\n\r\nThis is an almost direct port of [todoModel.js](https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/todoModel.js)\r\nwhich separates de logic of the app from the views. The biggest difference is with\r\na line of code we can define our `Todo` type and let the F# compiler statically check\r\nwe're always manipulating the structure correctly.\r\n*)\r\n\r\ntype Todo = { id: Guid; title: string; completed: bool }\r\n\r\ntype TodoModel(key) =\r\n    member val key = key\r\n    member val todos: Todo[] = defaultArg (Util.load key) [||] with get, set\r\n    member val onChanges: (unit->unit)[] = [||] with get, set\r\n\r\n    member this.subscribe(onChange) =\r\n        this.onChanges <- [|onChange|]\r\n\r\n    member this.inform() =\r\n        Util.save this.key this.todos\r\n        this.onChanges |> Seq.iter (fun cb -> cb())\r\n\r\n    member this.addTodo(title) =\r\n        this.todos <-\r\n            [|{ id=Guid.NewGuid(); title=title; completed=false }|]\r\n            |> Array.append this.todos\r\n        this.inform()\r\n\r\n    member this.toggleAll(checked') =\r\n        this.todos <- this.todos |> Array.map (fun todo ->\r\n            { todo with completed = checked' })\r\n        this.inform()\r\n\r\n    member this.toggle(todoToToggle) =\r\n        this.todos <- this.todos |> Array.map (fun todo ->\r\n            if todo.id <> todoToToggle.id\r\n            then todo\r\n            else { todo with completed = (not todo.completed) })\r\n        this.inform()\r\n\r\n    member this.destroy(todoToDestroy) =\r\n        this.todos <- this.todos |> Array.filter (fun todo ->\r\n            todo.id <> todoToDestroy.id)\r\n        this.inform()\r\n\r\n    member this.save(todoToSave, text) =\r\n        this.todos <- this.todos |> Array.map (fun todo ->\r\n            if todo.id <> todoToSave.id\r\n            then todo\r\n            else { todo with title = text })\r\n        this.inform()\r\n\r\n    member this.clearCompleted() =\r\n        this.todos <- this.todos |> Array.filter (fun todo ->\r\n            not todo.completed)\r\n        this.inform()\r\n\r\n(**\r\n## React views\r\n\r\nWe enter now in React's realm to define three views: TodoItem, TodoFooter and TodoApp.\r\nWe can use classes to define the views as explained in [React docs](https://facebook.github.io/react/docs/reusable-components.html#es6-classes),\r\ninheriting from `React.Component` and defining a `render` method, where we can use\r\nthe DSL defined in Fable's React helper to build HTML elements in a similar fashion\r\nas we would do with JSX.\r\n\r\n> For convenience, we use a module alias (`R`) to shorten references to the React helper.\r\n\r\nA big difference from JS is we can define simple models for the state and props\r\nof custom views, either by using records or interfaces, to allow for autocompletion\r\nand static checking, making our app much more robust than by using plain JS objects.\r\n\r\n*)\r\n\r\nmodule R = Fable.Helpers.React\r\nopen R.Props\r\n\r\ntype [<Pojo>] TodoItemProps =\r\n    { key: Guid\r\n    ; todo: Todo\r\n    ; editing: bool\r\n    ; onSave: string->unit\r\n    ; onEdit: React.SyntheticEvent->unit\r\n    ; onDestroy: React.SyntheticEvent->unit\r\n    ; onCancel: React.SyntheticEvent->unit\r\n    ; onToggle: React.SyntheticEvent->unit }\r\n\r\ntype [<Pojo>] TodoItemState =\r\n    { editText: string }\r\n\r\nlet [<Literal>] ESCAPE_KEY = 27.\r\nlet [<Literal>] ENTER_KEY = 13.\r\nlet [<Literal>] ALL_TODOS = \"all\"\r\nlet [<Literal>] ACTIVE_TODOS = \"active\"\r\nlet [<Literal>] COMPLETED_TODOS = \"completed\"\r\n\r\ntype TodoItem(props) =\r\n    inherit React.Component<TodoItemProps, TodoItemState>(props)\r\n    do base.setInitState({ editText = props.todo.title })\r\n\r\n    let mutable editField: Browser.HTMLInputElement option = None\r\n\r\n    member this.handleSubmit (e: React.SyntheticEvent) =\r\n        match this.state.editText.Trim() with\r\n        | value when value.Length > 0 ->\r\n            this.props.onSave(value)\r\n            this.setState { editText = value }\r\n        | _ ->\r\n            this.props.onDestroy(e)\r\n\r\n    member this.handleEdit (ev: React.MouseEvent) =\r\n        this.props.onEdit(upcast ev)\r\n        this.setState { editText = this.props.todo.title }\r\n\r\n    member this.handleKeyDown (e: React.KeyboardEvent) =\r\n        match e.which with\r\n        | ESCAPE_KEY ->\r\n            this.setState { editText = this.props.todo.title }\r\n            this.props.onCancel(upcast e)\r\n        | ENTER_KEY ->\r\n            this.handleSubmit(e)\r\n        | _ -> ()\r\n\r\n    member this.handleChange (e: React.SyntheticEvent) =\r\n        if this.props.editing then\r\n            this.setState { editText = string e.target?value }\r\n\r\n    member this.shouldComponentUpdate (nextProps: TodoItemProps) (nextState: TodoItemState) =\r\n        not(obj.ReferenceEquals(nextProps.todo, this.props.todo))\r\n        || nextProps.editing <> this.props.editing\r\n        || nextState.editText <> this.state.editText\r\n\r\n    member this.componentDidUpdate (prevProps: TodoItemProps) =\r\n        if not prevProps.editing && this.props.editing then\r\n            match editField with\r\n            | None -> ()\r\n            | Some node ->\r\n                node.focus()\r\n                node.setSelectionRange(float node.value.Length, float node.value.Length)\r\n\r\n    member this.render () =\r\n        let className =\r\n            classNames(\r\n                createObj [\r\n                    \"completed\" ==> this.props.todo.completed\r\n                    \"editing\" ==> this.props.editing\r\n                ])\r\n        // The React helper defines a simple DSL to build HTML elements.\r\n        // For more info about transforming F# unions to JS option objects:\r\n        // https://fable-compiler.github.io/docs/interacting.html#KeyValueList-attribute\r\n        R.li [ ClassName className ] [\r\n            R.div [ ClassName \"view\" ] [\r\n                R.input [\r\n                    ClassName \"toggle\"\r\n                    Type \"checkbox\"\r\n                    Checked this.props.todo.completed\r\n                    OnChange (fun e -> this.props.onToggle(upcast e))\r\n                ] []\r\n                R.label [ OnDoubleClick this.handleEdit ]\r\n                        [ R.str this.props.todo.title ]\r\n                R.button [\r\n                    ClassName \"destroy\"\r\n                    OnClick (fun e -> this.props.onDestroy(upcast e)) ] [ ]\r\n            ]\r\n            R.input [\r\n                ClassName \"edit\"\r\n                Ref (fun x -> editField <- Some(x:?>Browser.HTMLInputElement))\r\n                Value (U2.Case1 this.state.editText)\r\n                OnBlur this.handleSubmit\r\n                OnChange this.handleChange\r\n                OnKeyDown this.handleKeyDown\r\n            ] []\r\n        ]\r\n\r\n(**\r\nThe next view is `TodoFooter`. This component just presents some buttons below\r\nthe Todo list to filter by or change the `completed` property of the Todos.\r\n\r\nSame as `TodoItem`, notice the component subscribes to some events (like `OnClick`)\r\nbut instead of containing the logic to react to the event it just runs a callback\r\nreceived from its parent through the `props` object. Remember the state of React\r\ncomponents cannot be directly updated, so this is a way to transmit the event to\r\nthe parent and let it re-render the subtree if necessary.\r\n*)\r\n\r\ntype [<Pojo>] TodoFooterProps =\r\n    { count: int\r\n    ; completedCount: int\r\n    ; onClearCompleted: React.MouseEvent->unit\r\n    ; nowShowing: string }\r\n\r\nlet TodoFooter(props: TodoFooterProps) =\r\n    let activeTodoWord =\r\n        \"item\" + (if props.count = 1 then \"\" else \"s\")\r\n    let clearButton =\r\n        if props.completedCount > 0\r\n        then\r\n            R.button [\r\n                ClassName \"clear-completed\"\r\n                OnClick props.onClearCompleted\r\n            ] [ R.str \"Clear completed\" ] |> Some\r\n        else None\r\n    let className category =\r\n        classNames(\r\n            createObj [\"selected\" ==> (props.nowShowing = category)])\r\n    R.footer [ ClassName \"footer\" ] [\r\n        R.span [ ClassName \"todo-count\" ] [\r\n            R.strong [] [ props.count |> string |> R.str ]\r\n            R.str (\" \" + activeTodoWord + \" left\")\r\n        ]\r\n        R.ul [ ClassName \"filters\" ] [\r\n            R.li [] [\r\n                R.a [\r\n                    Href \"#/\"\r\n                    ClassName (className ALL_TODOS)\r\n                ] [ R.str \"All\" ] ]\r\n            R.str \" \"\r\n            R.li [] [\r\n                R.a [\r\n                    Href \"#/active\"\r\n                    ClassName (className ACTIVE_TODOS)\r\n                ] [ R.str \"Active\" ] ]\r\n            R.str \" \"\r\n            R.li [] [\r\n                R.a [\r\n                    Href \"#/completed\"\r\n                    ClassName (className COMPLETED_TODOS)\r\n                ] [ R.str \"Completed\" ] ]\r\n            R.opt clearButton\r\n        ]\r\n    ]\r\n\r\n(**\r\nWe finish with the `TodoApp` view. This component is the parent of the two previously\r\ndefined components, which are invoked in `render` by calling the `R.com` helper.\r\nNotice that, among the arguments of `R.com`, we use F# object expressions to build the props.\r\n\r\nIn the [original JS implementation](https://github.com/tastejs/todomvc/blob/gh-pages/examples/react/js/app.jsx#L28)\r\nof `componentDidMount` method, we need to take care to preserve the meaning of `this`\r\nwhen passing a lambda to another object by using `bind`. Luckily, that's not something\r\nwe need to worry about in Fable :)\r\n\r\nNote also we haven't defined an interface for the object returned by `Router`,\r\nso we just access its `init` method with the dynamic `?` operator.\r\n*)\r\n\r\ntype [<Pojo>] TodoAppProps =\r\n    { model: TodoModel }\r\n\r\ntype [<Pojo>] TodoAppState =\r\n    { nowShowing: string\r\n    ; editing: Guid option\r\n    ; newTodo: string }\r\n\r\ntype TodoApp(props) =\r\n    inherit React.Component<TodoAppProps, TodoAppState>(props)\r\n    do base.setInitState({ nowShowing=ALL_TODOS; editing=None; newTodo=\"\" })\r\n\r\n    member this.componentDidMount () =\r\n        let nowShowing category =\r\n            fun () -> this.setState({this.state with nowShowing = category})\r\n        let router =\r\n            Router(createObj [\r\n                    \"/\" ==> nowShowing ALL_TODOS\r\n                    \"/active\" ==> nowShowing ACTIVE_TODOS\r\n                    \"/completed\" ==> nowShowing COMPLETED_TODOS\r\n            ])\r\n        router?init(\"/\")\r\n\r\n    member this.handleChange (ev: React.SyntheticEvent) =\r\n        this.setState({ this.state with newTodo = string ev.target?value })\r\n\r\n    member this.handleNewTodoKeyDown (ev: React.KeyboardEvent) =\r\n        if ev.keyCode = ENTER_KEY then\r\n            ev.preventDefault()\r\n            let v = this.state.newTodo.Trim()\r\n            if v.Length > 0 then\r\n                this.props.model.addTodo(v)\r\n                this.setState({ this.state with newTodo = \"\" })\r\n\r\n    member this.toggleAll (ev: React.SyntheticEvent) =\r\n        this.props.model.toggleAll(unbox ev.target?``checked``)\r\n\r\n    member this.toggle (todoToToggle) =\r\n        this.props.model.toggle(todoToToggle)\r\n\r\n    member this.destroy (todo) =\r\n        this.props.model.destroy(todo)\r\n\r\n    member this.edit (todo: Todo) =\r\n        this.setState({ this.state with editing = Some todo.id })\r\n\r\n    member this.save (todoToSave, text) =\r\n        this.props.model.save(todoToSave, text)\r\n        this.setState({ this.state with editing = None })\r\n\r\n    member this.cancel () =\r\n        this.setState({ this.state with editing = None })\r\n\r\n    member this.clearCompleted () =\r\n        this.props.model.clearCompleted()\r\n\r\n    member this.render () =\r\n        let todos = this.props.model.todos\r\n        let todoItems =\r\n            todos\r\n            |> Seq.filter (fun todo ->\r\n                match this.state.nowShowing with\r\n                | ACTIVE_TODOS -> not todo.completed\r\n                | COMPLETED_TODOS -> todo.completed\r\n                | _ -> true)\r\n            |> Seq.map (fun todo ->\r\n                R.com<TodoItem,_,_>\r\n                    { key = todo.id\r\n                    ; todo = todo\r\n                    ; onToggle = fun _ -> this.toggle(todo)\r\n                    ; onDestroy = fun _ -> this.destroy(todo)\r\n                    ; onEdit = fun _ -> this.edit(todo)\r\n                    ; editing =\r\n                        match this.state.editing with\r\n                        | Some editing -> editing = todo.id\r\n                        | None -> false\r\n                    ; onSave = fun text -> this.save(todo, string text)\r\n                    ; onCancel = fun _ -> this.cancel() } [])\r\n                |> Seq.toList\r\n        let activeTodoCount =\r\n            todos |> Array.fold (fun accum todo ->\r\n                if todo.completed then accum else accum + 1\r\n            ) 0\r\n        let completedCount =\r\n            todos.Length - activeTodoCount\r\n        let footer =\r\n            if activeTodoCount > 0 || completedCount > 0\r\n            then\r\n                R.fn TodoFooter\r\n                    { count = activeTodoCount\r\n                    ; completedCount = completedCount\r\n                    ; nowShowing = this.state.nowShowing\r\n                    ; onClearCompleted = fun _ -> this.clearCompleted() } []\r\n                |> Some\r\n            else None\r\n        let main =\r\n            if todos.Length > 0\r\n            then\r\n                R.section [ ClassName \"main\" ] [\r\n                    R.input [\r\n                        ClassName \"toggle-all\"\r\n                        Type \"checkbox\"\r\n                        OnChange this.toggleAll\r\n                        Checked (activeTodoCount = 0)\r\n                    ] []\r\n                    R.ul [ ClassName \"todo-list\" ] todoItems\r\n                ] |> Some\r\n            else None\r\n        R.div [] [\r\n            R.header [ ClassName \"header\" ] [\r\n                R.h1 [] [ R.str \"todos\" ]\r\n                R.input [\r\n                    ClassName \"new-todo\"\r\n                    Placeholder \"What needs to be done?\"\r\n                    Value (U2.Case1 this.state.newTodo)\r\n                    OnKeyDown this.handleNewTodoKeyDown\r\n                    OnChange this.handleChange\r\n                    AutoFocus true\r\n                ] []\r\n            ]\r\n            R.opt main\r\n            R.opt footer\r\n        ]\r\n\r\n(**\r\n## Firing up the app\r\n\r\nThere's nothing left to do but building our model, mount our `TodoApp` view\r\nin the DOM by using `ReactDom.render` and subscribe to the events. Happy coding!\r\n*)\r\n\r\nlet model = TodoModel(\"react-todos\")\r\nlet render() =\r\n    ReactDom.render(\r\n        R.com<TodoApp,_,_> { model = model } [],\r\n        Browser.document.getElementsByClassName(\"todoapp\").[0]\r\n    )\r\nmodel.subscribe(render)\r\nrender()\r\n\r\n\r\nlet add x y = x + y\r\n"]}